<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/parser.js | @fluent/syntax</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="AST and parser for Fluent"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@fluent/syntax"><meta property="twitter:description" content="AST and parser for Fluent"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/projectfluent/fluent.js.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Annotation.html">Annotation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Attribute.html">Attribute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~BaseComment.html">BaseComment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~BaseNode.html">BaseNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~CallArguments.html">CallArguments</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Comment.html">Comment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Entry.html">Entry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Expression.html">Expression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~FunctionReference.html">FunctionReference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~GroupComment.html">GroupComment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Identifier.html">Identifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Junk.html">Junk</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Literal.html">Literal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Message.html">Message</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~MessageReference.html">MessageReference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~NamedArgument.html">NamedArgument</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~NumberLiteral.html">NumberLiteral</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Pattern.html">Pattern</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~PatternElement.html">PatternElement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Placeable.html">Placeable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Resource.html">Resource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~ResourceComment.html">ResourceComment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~SelectExpression.html">SelectExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Span.html">Span</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~StringLiteral.html">StringLiteral</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~SyntaxNode.html">SyntaxNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Term.html">Term</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~TermReference.html">TermReference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~TextElement.html">TextElement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~VariableReference.html">VariableReference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ast.js~Variant.html">Variant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors.js~ParseError.html">ParseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/parser.js~FluentParser.html">FluentParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/serializer.js~FluentSerializer.html">FluentSerializer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/stream.js~FluentParserStream.html">FluentParserStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/stream.js~ParserStream.html">ParserStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/visitor.js~Transformer.html">Transformer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/visitor.js~Visitor.html">Visitor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-columnOffset">columnOffset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineOffset">lineOffset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parse">parse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-serialize">serialize</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-serializeExpression">serializeExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-serializeVariantKey">serializeVariantKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-includes">includes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HAS_ENTRIES">HAS_ENTRIES</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EOF">EOF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EOL">EOL</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/parser.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*  eslint no-magic-numbers: [0]  */

import * as AST from &quot;./ast&quot;;
import { EOF, EOL, FluentParserStream } from &quot;./stream&quot;;
import { ParseError } from &quot;./errors&quot;;


const trailingWSRe = /[ \t\n\r]+$/;


function withSpan(fn) {
  return function(ps, ...args) {
    if (!this.withSpans) {
      return fn.call(this, ps, ...args);
    }

    const start = ps.index;
    const node = fn.call(this, ps, ...args);

    // Don&apos;t re-add the span if the node already has it. This may happen when
    // one decorated function calls another decorated function.
    if (node.span) {
      return node;
    }

    const end = ps.index;
    node.addSpan(start, end);
    return node;
  };
}


export
class FluentParser {
  constructor({
    withSpans = true,
  } = {}) {
    this.withSpans = withSpans;

    // Poor man&apos;s decorators.
    const methodNames = [
      &quot;getComment&quot;, &quot;getMessage&quot;, &quot;getTerm&quot;, &quot;getAttribute&quot;, &quot;getIdentifier&quot;,
      &quot;getVariant&quot;, &quot;getNumber&quot;, &quot;getPattern&quot;, &quot;getTextElement&quot;,
      &quot;getPlaceable&quot;, &quot;getExpression&quot;, &quot;getInlineExpression&quot;,
      &quot;getCallArgument&quot;, &quot;getCallArguments&quot;, &quot;getString&quot;, &quot;getLiteral&quot;,
    ];
    for (const name of methodNames) {
      this[name] = withSpan(this[name]);
    }
  }

  parse(source) {
    const ps = new FluentParserStream(source);
    ps.skipBlankBlock();

    const entries = [];
    let lastComment = null;

    while (ps.currentChar) {
      const entry = this.getEntryOrJunk(ps);
      const blankLines = ps.skipBlankBlock();

      // Regular Comments require special logic. Comments may be attached to
      // Messages or Terms if they are followed immediately by them. However
      // they should parse as standalone when they&apos;re followed by Junk.
      // Consequently, we only attach Comments once we know that the Message
      // or the Term parsed successfully.
      if (entry.type === &quot;Comment&quot;
          &amp;&amp; blankLines.length === 0
          &amp;&amp; ps.currentChar) {
        // Stash the comment and decide what to do with it in the next pass.
        lastComment = entry;
        continue;
      }

      if (lastComment) {
        if (entry.type === &quot;Message&quot; || entry.type === &quot;Term&quot;) {
          entry.comment = lastComment;
          if (this.withSpans) {
            entry.span.start = entry.comment.span.start;
          }
        } else {
          entries.push(lastComment);
        }
        // In either case, the stashed comment has been dealt with; clear it.
        lastComment = null;
      }

      // No special logic for other types of entries.
      entries.push(entry);
    }

    const res = new AST.Resource(entries);

    if (this.withSpans) {
      res.addSpan(0, ps.index);
    }

    return res;
  }

  /*
   * Parse the first Message or Term in `source`.
   *
   * Skip all encountered comments and start parsing at the first Message or
   * Term start. Return Junk if the parsing is not successful.
   *
   * Preceding comments are ignored unless they contain syntax errors
   * themselves, in which case Junk for the invalid comment is returned.
   */
  parseEntry(source) {
    const ps = new FluentParserStream(source);
    ps.skipBlankBlock();

    while (ps.currentChar === &quot;#&quot;) {
      const skipped = this.getEntryOrJunk(ps);
      if (skipped.type === &quot;Junk&quot;) {
        // Don&apos;t skip Junk comments.
        return skipped;
      }
      ps.skipBlankBlock();
    }

    return this.getEntryOrJunk(ps);
  }

  getEntryOrJunk(ps) {
    const entryStartPos = ps.index;

    try {
      const entry = this.getEntry(ps);
      ps.expectLineEnd();
      return entry;
    } catch (err) {
      if (!(err instanceof ParseError)) {
        throw err;
      }

      let errorIndex = ps.index;
      ps.skipToNextEntryStart(entryStartPos);
      const nextEntryStart = ps.index;
      if (nextEntryStart &lt; errorIndex) {
        // The position of the error must be inside of the Junk&apos;s span.
        errorIndex = nextEntryStart;
      }

      // Create a Junk instance
      const slice = ps.string.substring(entryStartPos, nextEntryStart);
      const junk = new AST.Junk(slice);
      if (this.withSpans) {
        junk.addSpan(entryStartPos, nextEntryStart);
      }
      const annot = new AST.Annotation(err.code, err.args, err.message);
      annot.addSpan(errorIndex, errorIndex);
      junk.addAnnotation(annot);
      return junk;
    }
  }

  getEntry(ps) {
    if (ps.currentChar === &quot;#&quot;) {
      return this.getComment(ps);
    }

    if (ps.currentChar === &quot;-&quot;) {
      return this.getTerm(ps);
    }

    if (ps.isIdentifierStart()) {
      return this.getMessage(ps);
    }

    throw new ParseError(&quot;E0002&quot;);
  }

  getComment(ps) {
    // 0 - comment
    // 1 - group comment
    // 2 - resource comment
    let level = -1;
    let content = &quot;&quot;;

    while (true) {
      let i = -1;
      while (ps.currentChar === &quot;#&quot; &amp;&amp; (i &lt; (level === -1 ? 2 : level))) {
        ps.next();
        i++;
      }

      if (level === -1) {
        level = i;
      }

      if (ps.currentChar !== EOL) {
        ps.expectChar(&quot; &quot;);
        let ch;
        while ((ch = ps.takeChar(x =&gt; x !== EOL))) {
          content += ch;
        }
      }

      if (ps.isNextLineComment(level)) {
        content += ps.currentChar;
        ps.next();
      } else {
        break;
      }
    }

    let Comment;
    switch (level) {
      case 0:
        Comment = AST.Comment;
        break;
      case 1:
        Comment = AST.GroupComment;
        break;
      case 2:
        Comment = AST.ResourceComment;
        break;
    }
    return new Comment(content);
  }

  getMessage(ps) {
    const id = this.getIdentifier(ps);

    ps.skipBlankInline();
    ps.expectChar(&quot;=&quot;);

    const value = this.maybeGetPattern(ps);
    const attrs = this.getAttributes(ps);

    if (value === null &amp;&amp; attrs.length === 0) {
      throw new ParseError(&quot;E0005&quot;, id.name);
    }

    return new AST.Message(id, value, attrs);
  }

  getTerm(ps) {
    ps.expectChar(&quot;-&quot;);
    const id = this.getIdentifier(ps);

    ps.skipBlankInline();
    ps.expectChar(&quot;=&quot;);

    const value = this.maybeGetPattern(ps);
    if (value === null) {
      throw new ParseError(&quot;E0006&quot;, id.name);
    }

    const attrs = this.getAttributes(ps);
    return new AST.Term(id, value, attrs);
  }

  getAttribute(ps) {
    ps.expectChar(&quot;.&quot;);

    const key = this.getIdentifier(ps);

    ps.skipBlankInline();
    ps.expectChar(&quot;=&quot;);

    const value = this.maybeGetPattern(ps);
    if (value === null) {
      throw new ParseError(&quot;E0012&quot;);
    }

    return new AST.Attribute(key, value);
  }

  getAttributes(ps) {
    const attrs = [];
    ps.peekBlank();
    while (ps.isAttributeStart()) {
      ps.skipToPeek();
      const attr = this.getAttribute(ps);
      attrs.push(attr);
      ps.peekBlank();
    }
    return attrs;
  }

  getIdentifier(ps) {
    let name = ps.takeIDStart();

    let ch;
    while ((ch = ps.takeIDChar())) {
      name += ch;
    }

    return new AST.Identifier(name);
  }

  getVariantKey(ps) {
    const ch = ps.currentChar;

    if (ch === EOF) {
      throw new ParseError(&quot;E0013&quot;);
    }

    const cc = ch.charCodeAt(0);

    if ((cc &gt;= 48 &amp;&amp; cc &lt;= 57) || cc === 45) { // 0-9, -
      return this.getNumber(ps);
    }

    return this.getIdentifier(ps);
  }

  getVariant(ps, {hasDefault}) {
    let defaultIndex = false;

    if (ps.currentChar === &quot;*&quot;) {
      if (hasDefault) {
        throw new ParseError(&quot;E0015&quot;);
      }
      ps.next();
      defaultIndex = true;
    }

    ps.expectChar(&quot;[&quot;);

    ps.skipBlank();

    const key = this.getVariantKey(ps);

    ps.skipBlank();
    ps.expectChar(&quot;]&quot;);

    const value = this.maybeGetPattern(ps);
    if (value === null) {
      throw new ParseError(&quot;E0012&quot;);
    }

    return new AST.Variant(key, value, defaultIndex);
  }

  getVariants(ps) {
    const variants = [];
    let hasDefault = false;

    ps.skipBlank();
    while (ps.isVariantStart()) {
      const variant = this.getVariant(ps, {hasDefault});

      if (variant.default) {
        hasDefault = true;
      }

      variants.push(variant);
      ps.expectLineEnd();
      ps.skipBlank();
    }

    if (variants.length === 0) {
      throw new ParseError(&quot;E0011&quot;);
    }

    if (!hasDefault) {
      throw new ParseError(&quot;E0010&quot;);
    }

    return variants;
  }

  getDigits(ps) {
    let num = &quot;&quot;;

    let ch;
    while ((ch = ps.takeDigit())) {
      num += ch;
    }

    if (num.length === 0) {
      throw new ParseError(&quot;E0004&quot;, &quot;0-9&quot;);
    }

    return num;
  }

  getNumber(ps) {
    let value = &quot;&quot;;

    if (ps.currentChar === &quot;-&quot;) {
      ps.next();
      value += `-${this.getDigits(ps)}`;
    } else {
      value += this.getDigits(ps);
    }

    if (ps.currentChar === &quot;.&quot;) {
      ps.next();
      value += `.${this.getDigits(ps)}`;
    }

    return new AST.NumberLiteral(value);
  }

  // maybeGetPattern distinguishes between patterns which start on the same line
  // as the identifier (a.k.a. inline signleline patterns and inline multiline
  // patterns) and patterns which start on a new line (a.k.a. block multiline
  // patterns). The distinction is important for the dedentation logic: the
  // indent of the first line of a block pattern must be taken into account when
  // calculating the maximum common indent.
  maybeGetPattern(ps) {
    ps.peekBlankInline();
    if (ps.isValueStart()) {
      ps.skipToPeek();
      return this.getPattern(ps, {isBlock: false});
    }

    ps.peekBlankBlock();
    if (ps.isValueContinuation()) {
      ps.skipToPeek();
      return this.getPattern(ps, {isBlock: true});
    }

    return null;
  }

  getPattern(ps, {isBlock}) {
    const elements = [];
    if (isBlock) {
      // A block pattern is a pattern which starts on a new line. Store and
      // measure the indent of this first line for the dedentation logic.
      const blankStart = ps.index;
      const firstIndent = ps.skipBlankInline();
      elements.push(this.getIndent(ps, firstIndent, blankStart));
      var commonIndentLength = firstIndent.length;
    } else {
      commonIndentLength = Infinity;
    }

    let ch;
    elements: while ((ch = ps.currentChar)) {
      switch (ch) {
        case EOL: {
          const blankStart = ps.index;
          const blankLines = ps.peekBlankBlock();
          if (ps.isValueContinuation()) {
            ps.skipToPeek();
            const indent = ps.skipBlankInline();
            commonIndentLength = Math.min(commonIndentLength, indent.length);
            elements.push(this.getIndent(ps, blankLines + indent, blankStart));
            continue elements;
          }

          // The end condition for getPattern&apos;s while loop is a newline
          // which is not followed by a valid pattern continuation.
          ps.resetPeek();
          break elements;
        }
        case &quot;{&quot;:
          elements.push(this.getPlaceable(ps));
          continue elements;
        case &quot;}&quot;:
          throw new ParseError(&quot;E0027&quot;);
        default:
          const element = this.getTextElement(ps);
          elements.push(element);
      }
    }

    const dedented = this.dedent(elements, commonIndentLength);
    return new AST.Pattern(dedented);
  }

  // Create a token representing an indent. It&apos;s not part of the AST and it will
  // be trimmed and merged into adjacent TextElements, or turned into a new
  // TextElement, if it&apos;s surrounded by two Placeables.
  getIndent(ps, value, start) {
    return {
      type: &quot;Indent&quot;,
      span: {start, end: ps.index},
      value,
    };
  }

  // Dedent a list of elements by removing the maximum common indent from the
  // beginning of text lines. The common indent is calculated in getPattern.
  dedent(elements, commonIndent) {
    const trimmed = [];

    for (let element of elements) {
      if (element.type === &quot;Placeable&quot;) {
        trimmed.push(element);
        continue;
      }

      if (element.type === &quot;Indent&quot;) {
        // Strip common indent.
        element.value = element.value.slice(
          0, element.value.length - commonIndent);
        if (element.value.length === 0) {
          continue;
        }
      }

      let prev = trimmed[trimmed.length - 1];
      if (prev &amp;&amp; prev.type === &quot;TextElement&quot;) {
        // Join adjacent TextElements by replacing them with their sum.
        const sum = new AST.TextElement(prev.value + element.value);
        if (this.withSpans) {
          sum.addSpan(prev.span.start, element.span.end);
        }
        trimmed[trimmed.length - 1] = sum;
        continue;
      }

      if (element.type === &quot;Indent&quot;) {
        // If the indent hasn&apos;t been merged into a preceding TextElement,
        // convert it into a new TextElement.
        const textElement = new AST.TextElement(element.value);
        if (this.withSpans) {
          textElement.addSpan(element.span.start, element.span.end);
        }
        element = textElement;
      }

      trimmed.push(element);
    }

    // Trim trailing whitespace from the Pattern.
    const lastElement = trimmed[trimmed.length - 1];
    if (lastElement.type === &quot;TextElement&quot;) {
      lastElement.value = lastElement.value.replace(trailingWSRe, &quot;&quot;);
      if (lastElement.value.length === 0) {
        trimmed.pop();
      }
    }

    return trimmed;
  }

  getTextElement(ps) {
    let buffer = &quot;&quot;;

    let ch;
    while ((ch = ps.currentChar)) {
      if (ch === &quot;{&quot; || ch === &quot;}&quot;) {
        return new AST.TextElement(buffer);
      }

      if (ch === EOL) {
        return new AST.TextElement(buffer);
      }

      buffer += ch;
      ps.next();
    }

    return new AST.TextElement(buffer);
  }

  getEscapeSequence(ps) {
    const next = ps.currentChar;

    switch (next) {
      case &quot;\\&quot;:
      case &quot;\&quot;&quot;:
        ps.next();
        return `\\${next}`;
      case &quot;u&quot;:
        return this.getUnicodeEscapeSequence(ps, next, 4);
      case &quot;U&quot;:
        return this.getUnicodeEscapeSequence(ps, next, 6);
      default:
        throw new ParseError(&quot;E0025&quot;, next);
    }
  }

  getUnicodeEscapeSequence(ps, u, digits) {
    ps.expectChar(u);

    let sequence = &quot;&quot;;
    for (let i = 0; i &lt; digits; i++) {
      const ch = ps.takeHexDigit();

      if (!ch) {
        throw new ParseError(
          &quot;E0026&quot;, `\\${u}${sequence}${ps.currentChar}`);
      }

      sequence += ch;
    }

    return `\\${u}${sequence}`;
  }

  getPlaceable(ps) {
    ps.expectChar(&quot;{&quot;);
    ps.skipBlank();
    const expression = this.getExpression(ps);
    ps.expectChar(&quot;}&quot;);
    return new AST.Placeable(expression);
  }

  getExpression(ps) {
    const selector = this.getInlineExpression(ps);
    ps.skipBlank();

    if (ps.currentChar === &quot;-&quot;) {
      if (ps.peek() !== &quot;&gt;&quot;) {
        ps.resetPeek();
        return selector;
      }

      // Validate selector expression according to
      // abstract.js in the Fluent specification
      switch (selector.type) {
        case &quot;MessageReference&quot;:
          if (selector.attribute === null) {
            throw new ParseError(&quot;E0016&quot;);
          } else {
            throw new ParseError(&quot;E0018&quot;);
          }
        case &quot;TermReference&quot;:
          if (selector.attribute === null) {
            throw new ParseError(&quot;E0017&quot;);
          }
        case &quot;StringLiteral&quot;:
        case &quot;NumberLiteral&quot;:
        case &quot;VariableReference&quot;:
        case &quot;FunctionReference&quot;:
          break;
        default:
          throw new ParseError(&quot;E0029&quot;);
      }

      ps.next();
      ps.next();

      ps.skipBlankInline();
      ps.expectLineEnd();

      const variants = this.getVariants(ps);
      return new AST.SelectExpression(selector, variants);
    }

    if (selector.type === &quot;TermReference&quot; &amp;&amp; selector.attribute !== null) {
      throw new ParseError(&quot;E0019&quot;);
    }

    return selector;
  }

  getInlineExpression(ps) {
    if (ps.currentChar === &quot;{&quot;) {
      return this.getPlaceable(ps);
    }

    if (ps.isNumberStart()) {
      return this.getNumber(ps);
    }

    if (ps.currentChar === &apos;&quot;&apos;) {
      return this.getString(ps);
    }

    if (ps.currentChar === &quot;$&quot;) {
      ps.next();
      const id = this.getIdentifier(ps);
      return new AST.VariableReference(id);
    }

    if (ps.currentChar === &quot;-&quot;) {
      ps.next();
      const id = this.getIdentifier(ps);

      let attr;
      if (ps.currentChar === &quot;.&quot;) {
        ps.next();
        attr = this.getIdentifier(ps);
      }

      let args;
      ps.peekBlank();
      if (ps.currentPeek === &quot;(&quot;) {
        ps.skipToPeek();
        args = this.getCallArguments(ps);
      }

      return new AST.TermReference(id, attr, args);
    }

    if (ps.isIdentifierStart()) {
      const id = this.getIdentifier(ps);
      ps.peekBlank();

      if (ps.currentPeek === &quot;(&quot;) {
        // It&apos;s a Function. Ensure it&apos;s all upper-case.
        if (!/^[A-Z][A-Z0-9_-]*$/.test(id.name)) {
          throw new ParseError(&quot;E0008&quot;);
        }

        ps.skipToPeek();
        let args = this.getCallArguments(ps);
        return new AST.FunctionReference(id, args);
      }

      let attr;
      if (ps.currentChar === &quot;.&quot;) {
        ps.next();
        attr = this.getIdentifier(ps);
      }

      return new AST.MessageReference(id, attr);
    }


    throw new ParseError(&quot;E0028&quot;);
  }

  getCallArgument(ps) {
    const exp = this.getInlineExpression(ps);

    ps.skipBlank();

    if (ps.currentChar !== &quot;:&quot;) {
      return exp;
    }

    if (exp.type === &quot;MessageReference&quot; &amp;&amp; exp.attribute === null) {
      ps.next();
      ps.skipBlank();

      const value = this.getLiteral(ps);
      return new AST.NamedArgument(exp.id, value);
    }

    throw new ParseError(&quot;E0009&quot;);
  }

  getCallArguments(ps) {
    const positional = [];
    const named = [];
    const argumentNames = new Set();

    ps.expectChar(&quot;(&quot;);
    ps.skipBlank();

    while (true) {
      if (ps.currentChar === &quot;)&quot;) {
        break;
      }

      const arg = this.getCallArgument(ps);
      if (arg.type === &quot;NamedArgument&quot;) {
        if (argumentNames.has(arg.name.name)) {
          throw new ParseError(&quot;E0022&quot;);
        }
        named.push(arg);
        argumentNames.add(arg.name.name);
      } else if (argumentNames.size &gt; 0) {
        throw new ParseError(&quot;E0021&quot;);
      } else {
        positional.push(arg);
      }

      ps.skipBlank();

      if (ps.currentChar === &quot;,&quot;) {
        ps.next();
        ps.skipBlank();
        continue;
      }

      break;
    }

    ps.expectChar(&quot;)&quot;);
    return new AST.CallArguments(positional, named);
  }

  getString(ps) {
    ps.expectChar(&quot;\&quot;&quot;);
    let value = &quot;&quot;;

    let ch;
    while ((ch = ps.takeChar(x =&gt; x !== &apos;&quot;&apos; &amp;&amp; x !== EOL))) {
      if (ch === &quot;\\&quot;) {
        value += this.getEscapeSequence(ps);
      } else {
        value += ch;
      }
    }

    if (ps.currentChar === EOL) {
      throw new ParseError(&quot;E0020&quot;);
    }

    ps.expectChar(&quot;\&quot;&quot;);

    return new AST.StringLiteral(value);
  }

  getLiteral(ps) {
    if (ps.isNumberStart()) {
      return this.getNumber(ps);
    }

    if (ps.currentChar === &apos;&quot;&apos;) {
      return this.getString(ps);
    }

    throw new ParseError(&quot;E0014&quot;);
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
