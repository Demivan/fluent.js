<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/overlay.js | @fluent/dom</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Fluent bindings for DOM"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@fluent/dom"><meta property="twitter:description" content="Fluent bindings for DOM"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/projectfluent/fluent.js.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/dom_localization.js~DOMLocalization.html">DOMLocalization</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/localization.js~Localization.html">Localization</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-translateElement">translateElement</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/overlay.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint no-console: [&quot;error&quot;, {allow: [&quot;warn&quot;]}] */
/* global console */

// Match the opening angle bracket (&lt;) in HTML tags, and HTML entities like
// &amp;amp;, &amp;#0038;, &amp;#x0026;.
const reOverlay = /&lt;|&amp;#?\w+;/;

/**
 * Elements allowed in translations even if they are not present in the source
 * HTML. They are text-level elements as defined by the HTML5 spec:
 * https://www.w3.org/TR/html5/text-level-semantics.html with the exception of:
 *
 *   - a - because we don&apos;t allow href on it anyways,
 *   - ruby, rt, rp - because we don&apos;t allow nested elements to be inserted.
 */
const TEXT_LEVEL_ELEMENTS = {
  &quot;http://www.w3.org/1999/xhtml&quot;: [
    &quot;em&quot;, &quot;strong&quot;, &quot;small&quot;, &quot;s&quot;, &quot;cite&quot;, &quot;q&quot;, &quot;dfn&quot;, &quot;abbr&quot;, &quot;data&quot;,
    &quot;time&quot;, &quot;code&quot;, &quot;var&quot;, &quot;samp&quot;, &quot;kbd&quot;, &quot;sub&quot;, &quot;sup&quot;, &quot;i&quot;, &quot;b&quot;, &quot;u&quot;,
    &quot;mark&quot;, &quot;bdi&quot;, &quot;bdo&quot;, &quot;span&quot;, &quot;br&quot;, &quot;wbr&quot;
  ],
};

const LOCALIZABLE_ATTRIBUTES = {
  &quot;http://www.w3.org/1999/xhtml&quot;: {
    global: [&quot;title&quot;, &quot;aria-label&quot;, &quot;aria-valuetext&quot;],
    a: [&quot;download&quot;],
    area: [&quot;download&quot;, &quot;alt&quot;],
    // value is special-cased in isAttrNameLocalizable
    input: [&quot;alt&quot;, &quot;placeholder&quot;],
    menuitem: [&quot;label&quot;],
    menu: [&quot;label&quot;],
    optgroup: [&quot;label&quot;],
    option: [&quot;label&quot;],
    track: [&quot;label&quot;],
    img: [&quot;alt&quot;],
    textarea: [&quot;placeholder&quot;],
    th: [&quot;abbr&quot;]
  },
  &quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;: {
    global: [
      &quot;accesskey&quot;, &quot;aria-label&quot;, &quot;aria-valuetext&quot;, &quot;label&quot;,
      &quot;title&quot;, &quot;tooltiptext&quot;
    ],
    description: [&quot;value&quot;],
    key: [&quot;key&quot;, &quot;keycode&quot;],
    label: [&quot;value&quot;],
    textbox: [&quot;placeholder&quot;, &quot;value&quot;],
  }
};


/**
 * Translate an element.
 *
 * Translate the element&apos;s text content and attributes. Some HTML markup is
 * allowed in the translation. The element&apos;s children with the data-l10n-name
 * attribute will be treated as arguments to the translation. If the
 * translation defines the same children, their attributes and text contents
 * will be used for translating the matching source child.
 *
 * @param   {Element} element
 * @param   {Object} translation
 * @private
 */
export default function translateElement(element, translation) {
  const {value} = translation;

  if (typeof value === &quot;string&quot;) {
    if (element.localName === &quot;title&quot; &amp;&amp;
        element.namespaceURI === &quot;http://www.w3.org/1999/xhtml&quot;) {
      // A special case for the HTML title element whose content must be text.
      element.textContent = value;
    } else if (!reOverlay.test(value)) {
      // If the translation doesn&apos;t contain any markup skip the overlay logic.
      element.textContent = value;
    } else {
      // Else parse the translation&apos;s HTML using an inert template element,
      // sanitize it and replace the element&apos;s content.
      const templateElement = element.ownerDocument.createElementNS(
        &quot;http://www.w3.org/1999/xhtml&quot;, &quot;template&quot;
      );
      templateElement.innerHTML = value;
      overlayChildNodes(templateElement.content, element);
    }
  }

  // Even if the translation doesn&apos;t define any localizable attributes, run
  // overlayAttributes to remove any localizable attributes set by previous
  // translations.
  overlayAttributes(translation, element);
}

/**
 * Replace child nodes of an element with child nodes of another element.
 *
 * The contents of the target element will be cleared and fully replaced with
 * sanitized contents of the source element.
 *
 * @param {DocumentFragment} fromFragment - The source of children to overlay.
 * @param {Element} toElement - The target of the overlay.
 * @private
 */
function overlayChildNodes(fromFragment, toElement) {
  for (const childNode of fromFragment.childNodes) {
    if (childNode.nodeType === childNode.TEXT_NODE) {
      // Keep the translated text node.
      continue;
    }

    if (childNode.hasAttribute(&quot;data-l10n-name&quot;)) {
      const sanitized = getNodeForNamedElement(toElement, childNode);
      fromFragment.replaceChild(sanitized, childNode);
      continue;
    }

    if (isElementAllowed(childNode)) {
      const sanitized = createSanitizedElement(childNode);
      fromFragment.replaceChild(sanitized, childNode);
      continue;
    }

    console.warn(
      `An element of forbidden type &quot;${childNode.localName}&quot; was found in ` +
      &quot;the translation. Only safe text-level elements and elements with &quot; +
      &quot;data-l10n-name are allowed.&quot;
    );

    // If all else fails, replace the element with its text content.
    fromFragment.replaceChild(
      createTextNodeFromTextContent(childNode), childNode);
  }

  toElement.textContent = &quot;&quot;;
  toElement.appendChild(fromFragment);
}

function hasAttribute(attributes, name) {
  if (!attributes) {
    return false;
  }
  for (let attr of attributes) {
    if (attr.name === name) {
      return true;
    }
  }
  return false;
}

/**
 * Transplant localizable attributes of an element to another element.
 *
 * Any localizable attributes already set on the target element will be
 * cleared.
 *
 * @param   {Element|Object} fromElement - The source of child nodes to overlay.
 * @param   {Element} toElement - The target of the overlay.
 * @private
 */
function overlayAttributes(fromElement, toElement) {
  const explicitlyAllowed = toElement.hasAttribute(&quot;data-l10n-attrs&quot;)
    ? toElement.getAttribute(&quot;data-l10n-attrs&quot;)
      .split(&quot;,&quot;).map(i =&gt; i.trim())
    : null;

  // Remove existing localizable attributes if they
  // will not be used in the new translation.
  for (const attr of Array.from(toElement.attributes)) {
    if (isAttrNameLocalizable(attr.name, toElement, explicitlyAllowed)
      &amp;&amp; !hasAttribute(fromElement.attributes, attr.name)) {
      toElement.removeAttribute(attr.name);
    }
  }

  // fromElement might be a {value, attributes} object as returned by
  // Localization.messageFromBundle. In which case attributes may be null to
  // save GC cycles.
  if (!fromElement.attributes) {
    return;
  }

  // Set localizable attributes.
  for (const attr of Array.from(fromElement.attributes)) {
    if (isAttrNameLocalizable(attr.name, toElement, explicitlyAllowed)
      &amp;&amp; toElement.getAttribute(attr.name) !== attr.value) {
      toElement.setAttribute(attr.name, attr.value);
    }
  }
}

/**
 * Sanitize a child element created by the translation.
 *
 * Try to find a corresponding child in sourceElement and use it as the base
 * for the sanitization. This will preserve functional attribtues defined on
 * the child element in the source HTML.
 *
 * @param   {Element} sourceElement - The source for data-l10n-name lookups.
 * @param   {Element} translatedChild - The translated child to be sanitized.
 * @returns {Element}
 * @private
 */
function getNodeForNamedElement(sourceElement, translatedChild) {
  const childName = translatedChild.getAttribute(&quot;data-l10n-name&quot;);
  const sourceChild = sourceElement.querySelector(
    `[data-l10n-name=&quot;${childName}&quot;]`
  );

  if (!sourceChild) {
    console.warn(
      `An element named &quot;${childName}&quot; wasn&apos;t found in the source.`
    );
    return createTextNodeFromTextContent(translatedChild);
  }

  if (sourceChild.localName !== translatedChild.localName) {
    console.warn(
      `An element named &quot;${childName}&quot; was found in the translation ` +
      `but its type ${translatedChild.localName} didn&apos;t match the ` +
      `element found in the source (${sourceChild.localName}).`
    );
    return createTextNodeFromTextContent(translatedChild);
  }

  // Remove it from sourceElement so that the translation cannot use
  // the same reference name again.
  sourceElement.removeChild(sourceChild);
  // We can&apos;t currently guarantee that a translation won&apos;t remove
  // sourceChild from the element completely, which could break the app if
  // it relies on an event handler attached to the sourceChild. Let&apos;s make
  // this limitation explicit for now by breaking the identitiy of the
  // sourceChild by cloning it. This will destroy all event handlers
  // attached to sourceChild via addEventListener and via on&lt;name&gt;
  // properties.
  const clone = sourceChild.cloneNode(false);
  return shallowPopulateUsing(translatedChild, clone);
}

/**
 * Sanitize an allowed element.
 *
 * Text-level elements allowed in translations may only use safe attributes
 * and will have any nested markup stripped to text content.
 *
 * @param   {Element} element - The element to be sanitized.
 * @returns {Element}
 * @private
 */
function createSanitizedElement(element) {
  // Start with an empty element of the same type to remove nested children
  // and non-localizable attributes defined by the translation.
  const clone = element.ownerDocument.createElement(element.localName);
  return shallowPopulateUsing(element, clone);
}

/**
 * Convert an element to a text node.
 *
 * @param   {Element} element - The element to be sanitized.
 * @returns {Node}
 * @private
 */
function createTextNodeFromTextContent(element) {
  return element.ownerDocument.createTextNode(element.textContent);
}

/**
 * Check if element is allowed in the translation.
 *
 * This method is used by the sanitizer when the translation markup contains
 * an element which is not present in the source code.
 *
 * @param   {Element} element
 * @returns {boolean}
 * @private
 */
function isElementAllowed(element) {
  const allowed = TEXT_LEVEL_ELEMENTS[element.namespaceURI];
  return allowed &amp;&amp; allowed.includes(element.localName);
}

/**
 * Check if attribute is allowed for the given element.
 *
 * This method is used by the sanitizer when the translation markup contains
 * DOM attributes, or when the translation has traits which map to DOM
 * attributes.
 *
 * `explicitlyAllowed` can be passed as a list of attributes explicitly
 * allowed on this element.
 *
 * @param   {string}         name
 * @param   {Element}        element
 * @param   {Array}          explicitlyAllowed
 * @returns {boolean}
 * @private
 */
function isAttrNameLocalizable(name, element, explicitlyAllowed = null) {
  if (explicitlyAllowed &amp;&amp; explicitlyAllowed.includes(name)) {
    return true;
  }

  const allowed = LOCALIZABLE_ATTRIBUTES[element.namespaceURI];
  if (!allowed) {
    return false;
  }

  const attrName = name.toLowerCase();
  const elemName = element.localName;

  // Is it a globally safe attribute?
  if (allowed.global.includes(attrName)) {
    return true;
  }

  // Are there no allowed attributes for this element?
  if (!allowed[elemName]) {
    return false;
  }

  // Is it allowed on this element?
  if (allowed[elemName].includes(attrName)) {
    return true;
  }

  // Special case for value on HTML inputs with type button, reset, submit
  if (element.namespaceURI === &quot;http://www.w3.org/1999/xhtml&quot; &amp;&amp;
      elemName === &quot;input&quot; &amp;&amp; attrName === &quot;value&quot;) {
    const type = element.type.toLowerCase();
    if (type === &quot;submit&quot; || type === &quot;button&quot; || type === &quot;reset&quot;) {
      return true;
    }
  }

  return false;
}

/**
 * Helper to set textContent and localizable attributes on an element.
 *
 * @param   {Element} fromElement
 * @param   {Element} toElement
 * @returns {Element}
 * @private
 */
function shallowPopulateUsing(fromElement, toElement) {
  toElement.textContent = fromElement.textContent;
  overlayAttributes(fromElement, toElement);
  return toElement;
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
